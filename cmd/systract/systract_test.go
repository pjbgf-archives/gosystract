package systract

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/golang-collections/collections/stack"
	"github.com/stretchr/testify/assert"
)

func TestExtract_FileDoesNotExist(t *testing.T) {
	assert := assert.New(t)
	fileName := "/tmp/3216763872163876321"

	if _, err := os.Stat(fileName); err == nil {
		assert.Fail("test cannot run because file should not exist")
	}

	syscalls, err := Extract(NewDumpReader(fileName))

	assert.Error(err)
	assert.Len(syscalls, 0)
}

func TestExtract_E2E_LibrariesNotSupported(t *testing.T) {
	assert := assert.New(t)
	fileName, _ := filepath.Abs("../../test/systrac.dump")

	if _, err := os.Stat(fileName); err != nil {
		assert.Fail("test cannot run because systrac sample file does not exist")
	}

	syscalls, err := Extract(NewDumpReader(fileName))

	assert.Error(err)
	assert.Len(syscalls, 0)
}

func TestExtract_E2E_Executable(t *testing.T) {
	assert := assert.New(t)
	fileName, _ := filepath.Abs("../../test/keyring.dump")

	if _, err := os.Stat(fileName); err != nil {
		assert.Fail("test cannot run because keyring sample file does not exist")
	}

	expected := []SystemCall{
		{ID: 0x0, Name: "read"}, {ID: 0x18, Name: "sched_yield"},
		{ID: 0xca, Name: "futex"}, {ID: 0x1, Name: "write"},
		{ID: 0xe, Name: "rt_sigprocmask"}, {ID: 0x27, Name: "getpid"},
		{ID: 0xba, Name: "gettid"}, {ID: 0xea, Name: "tgkill"},
		{ID: 0xd, Name: "rt_sigaction"}, {ID: 0xe7, Name: "exit_group"},
		{ID: 0x9, Name: "mmap"}, {ID: 0x1c, Name: "madvise"},
		{ID: 0x6f, Name: "getpgrp"}, {ID: 0x9e, Name: "arch_prctl"},
		{ID: 0xf8, Name: "add_key"}, {ID: 0xfa, Name: "keyctl"},
	}

	actual, err := Extract(NewDumpReader(fileName))

	assert.Nil(err)
	assert.Equal(expected, actual)
}

func TestGetSyscallID(t *testing.T) {
	assertThat := func(assumption, assemblyLine string, expectedId uint16, expectedMatch bool) {
		assert := assert.New(t)

		id, ok := getSyscallID(assemblyLine)

		assert.Equal(expectedMatch, ok)
		assert.Equal(expectedId, id)
	}

	assertThat("should support golang.org/x/sys/unix.Syscall calls", "zsyscall_linux_amd64.go:442	0x48bd75		48c704247d000000	MOVQ $0x7d, 0(SP)", 125, true)
	assertThat("should support SYSCALL calls", "sys_linux_amd64.s:625	0x453610		b818000000		MOVL $0x18, AX", 24, true)
}

func TestIsCallInstruction(t *testing.T) {

	assertThat := func(assumption, assemblyLine, expectedTarget string, expectedMatch bool) {
		assert := assert.New(t)
		target, ok := getCallTarget(assemblyLine)

		assert.Equal(expectedMatch, ok)
		assert.Equal(expectedTarget, target)
	}

	assertThat("should match runtime funcs", "main.go:35		0x48c3d8		e8c334fcff		CALL runtime.morestack_noctxt(SB)", "runtime.morestack_noctxt", true)
	assertThat("should match composed funcs", "print.go:265		0x481553		e8c87b0000		CALL fmt.(*pp).doPrintln(SB)", "fmt.(*pp).doPrintln", true)
	assertThat("should match composed funcs 2", "print.go:134		0x480f9c		e84ff7fdff		CALL sync.(*Pool).Get(SB)", "sync.(*Pool).Get", true)
	assertThat("should not match funcs definition", "TEXT fmt.Fprintln(SB) /usr/local/go/src/fmt/print.go", "", false)
}

func TestGetSymbolName(t *testing.T) {

	assertThat := func(assumption, assemblyLine, expectedName string, expectedMatch bool) {
		assert := assert.New(t)
		actual, ok := getSymbolName(assemblyLine)

		assert.Equal(expectedMatch, ok)
		assert.Equal(expectedName, actual)
	}

	assertThat("should match main.main symbol", "TEXT main.main(SB) /media/pjb/src/git/learn-golang/caps/main.go", "main.main", true)
	assertThat("should match symbol with *", "TEXT sync.(*Pool).Get(SB) /usr/local/go/src/sync/pool.go", "sync.(*Pool).Get", true)
	assertThat("should match symbols with %", "TEXT %22%22.init(SB) gofile..<autogenerated>", "%22%22.init", true)
}

func TestIsEndOfSymbolDefinition(t *testing.T) {

	assertThat := func(assumption, assemblyLine string, expected bool) {
		assert := assert.New(t)
		actual := isEndOfSymbol(assemblyLine)

		assert.Equal(expected, actual)
	}

	assertThat("should match line break", "\n", true)
	assertThat("should match empty line", "", true)
	assertThat("should not match empty symbol definition line", "TEXT sync.(*Pool).Get(SB) /usr/local/go/src/sync/pool.go", false)
	assertThat("should not match empty symbol definition line", "TEXT sync.(*Pool).Get(SB) /usr/local/go/src/sync/pool.go", false)
}

func TestContainsSyscall(t *testing.T) {

	assertThat := func(assumption, assemblyLine string, expected bool) {
		assert := assert.New(t)
		containsSyscall := containsSyscall(assemblyLine)

		assert.Equal(expected, containsSyscall)
	}

	assertThat("should return true for syscall.Syscall instruction", "zsyscall_linux_amd64.go:310	0x47d56b		e8a0070000		CALL syscall.Syscall(SB)", true)
	assertThat("should return true for syscall.Syscall6 instruction", "sys_linux.go:149	0x4950b7		e8d48cfeff		CALL syscall.Syscall6(SB)		", true)
	assertThat("should return true for SYSCALL instruction", "sys_linux_amd64.s:535	0x4534f1		0f05			SYSCALL", true)
	assertThat("should return true for golang.org/x/sys/unix.Syscall instruction", "zsyscall_linux_amd64.go:442	0x48bd9a		e881030000		CALL golang.org/x/sys/unix.Syscall(SB)", true)
	assertThat("should return false for instructions containing syscall on their name", "proc.go:2853		0x430ab3		eb8b			JMP runtime.entersyscall_sysmon(SB)", false)
}

func TestTryPopSyscallID(t *testing.T) {

	assertThat := func(assumption, assemblyLine string, expectedID uint16, s *stack.Stack, expectedMatch bool) {
		assert := assert.New(t)
		actual, ok := tryPopSyscallID(assemblyLine, s)

		assert.Equal(expectedMatch, ok)
		assert.Equal(expectedID, actual)
	}

	stack := stack.New()
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd75		48c704247d000000	MOVQ $0x7d, 0(SP)				", stack)
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd7d		488b442440		MOVQ 0x40(SP), AX				", stack)
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd82		4889442408		MOVQ AX, 0x8(SP)					", stack)
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd91		48c744241800000000	MOVQ $0x0, 0x18(SP)				", stack)

	assertThat("should match main.main symbol", "zsyscall_linux_amd64.go:442	0x48bd9a		e881030000		CALL golang.org/x/sys/unix.Syscall(SB)", uint16(125), stack, true)
}

func TestStackSyscallIDIfNecessary(t *testing.T) {

	assert := assert.New(t)
	stack := stack.New()
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd75		48c704247d000000	MOVQ $0x7d, 0(SP)", stack)
	stackSyscallIDIfNecessary("sys_linux.go:230	0x49554e		48c70424fa000000		MOVQ $0xfa, 0(SP)", stack)
	stackSyscallIDIfNecessary("sys_linux_amd64.s:616	0x453aa5		48c7c702100000		MOVQ $0x1002, DI", stack)
	stackSyscallIDIfNecessary("sys_linux_amd64.s:617	0x453aac		48c7c09e000000		MOVQ $0x9e, AX", stack)

	assert.Equal(3, stack.Len())
	assert.Equal(uint16(158), stack.Pop())
	assert.Equal(uint16(250), stack.Pop())
	assert.Equal(uint16(125), stack.Pop())
}
