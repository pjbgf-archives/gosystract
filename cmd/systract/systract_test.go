package systract

import (
	"path/filepath"
	"testing"

	"github.com/golang-collections/collections/stack"
	"github.com/pjbgf/should"
)

func TestExtract_Errors(t *testing.T) {
	assertThat := func(assumption, fileName string, expectedLength int) {
		should := should.New(t)
		syscalls, err := Extract(NewDumpReader(fileName))

		should.Error(err, assumption)
		should.BeEqual(len(syscalls), expectedLength, assumption)
	}

	assertThat("should error when input file does not exist", "/tmp/3216763872163876321", 0)
	assertThat("should error when input file is go library", "../../test/systrac.dump", 0)
}

func TestExtract_E2E_Executable(t *testing.T) {
	should := should.New(t)
	fileName, _ := filepath.Abs("../../test/keyring.dump")

	expected := []SystemCall{
		{ID: 0x0, Name: "read"}, {ID: 0x18, Name: "sched_yield"},
		{ID: 0xca, Name: "futex"}, {ID: 0x1, Name: "write"},
		{ID: 0xe, Name: "rt_sigprocmask"}, {ID: 0x27, Name: "getpid"},
		{ID: 0xba, Name: "gettid"}, {ID: 0xea, Name: "tgkill"},
		{ID: 0xd, Name: "rt_sigaction"}, {ID: 0xe7, Name: "exit_group"},
		{ID: 0x9, Name: "mmap"}, {ID: 0x1c, Name: "madvise"},
		{ID: 0x6f, Name: "getpgrp"}, {ID: 0x9e, Name: "arch_prctl"},
		{ID: 0xf8, Name: "add_key"}, {ID: 0xfa, Name: "keyctl"},
	}

	actual, err := Extract(NewDumpReader(fileName))

	should.BeNil(err, "should not error for keyring.dump")
	should.BeEqual(expected, actual, "should match expected syscalls for keyring.dump")
}

func TestGetSyscallID(t *testing.T) {
	assertThat := func(assumption, assemblyLine string, expectedId uint16, expectedMatch bool) {
		should := should.New(t)

		id, ok := getSyscallID(assemblyLine)

		should.BeEqual(expectedMatch, ok, assumption)
		should.BeEqual(expectedId, id, assumption)
	}

	assertThat("should support golang.org/x/sys/unix.Syscall calls", "zsyscall_linux_amd64.go:442	0x48bd75		48c704247d000000	MOVQ $0x7d, 0(SP)", 125, true)
	assertThat("should support SYSCALL calls", "sys_linux_amd64.s:625	0x453610		b818000000		MOVL $0x18, AX", 24, true)
}

func TestIsCallInstruction(t *testing.T) {

	assertThat := func(assumption, assemblyLine, expectedTarget string, expectedMatch bool) {
		should := should.New(t)
		target, ok := getCallTarget(assemblyLine)

		should.BeEqual(expectedMatch, ok, assumption)
		should.BeEqual(expectedTarget, target, assumption)
	}

	assertThat("should match runtime funcs", "main.go:35		0x48c3d8		e8c334fcff		CALL runtime.morestack_noctxt(SB)", "runtime.morestack_noctxt", true)
	assertThat("should match composed funcs", "print.go:265		0x481553		e8c87b0000		CALL fmt.(*pp).doPrintln(SB)", "fmt.(*pp).doPrintln", true)
	assertThat("should match composed funcs 2", "print.go:134		0x480f9c		e84ff7fdff		CALL sync.(*Pool).Get(SB)", "sync.(*Pool).Get", true)
	assertThat("should not match funcs definition", "TEXT fmt.Fprintln(SB) /usr/local/go/src/fmt/print.go", "", false)
}

func TestGetSymbolName(t *testing.T) {

	assertThat := func(assumption, assemblyLine, expectedName string, expectedMatch bool) {
		should := should.New(t)
		actual, ok := getSymbolName(assemblyLine)

		should.BeEqual(expectedMatch, ok, assumption)
		should.BeEqual(expectedName, actual, assumption)
	}

	assertThat("should match main.main symbol", "TEXT main.main(SB) /media/pjb/src/git/learn-golang/caps/main.go", "main.main", true)
	assertThat("should match symbol with *", "TEXT sync.(*Pool).Get(SB) /usr/local/go/src/sync/pool.go", "sync.(*Pool).Get", true)
	assertThat("should match symbols with %", "TEXT %22%22.init(SB) gofile..<autogenerated>", "%22%22.init", true)
}

func TestIsEndOfSymbolDefinition(t *testing.T) {

	assertThat := func(assumption, assemblyLine string, expected bool) {
		should := should.New(t)
		actual := isEndOfSymbol(assemblyLine)

		should.BeEqual(expected, actual, assumption)
	}

	assertThat("should match line break", "\n", true)
	assertThat("should match empty line", "", true)
	assertThat("should not match empty symbol definition line", "TEXT sync.(*Pool).Get(SB) /usr/local/go/src/sync/pool.go", false)
	assertThat("should not match empty symbol definition line", "TEXT sync.(*Pool).Get(SB) /usr/local/go/src/sync/pool.go", false)
}

func TestContainsSyscall(t *testing.T) {

	assertThat := func(assumption, assemblyLine string, expected bool) {
		should := should.New(t)
		containsSyscall := containsSyscall(assemblyLine)

		should.BeEqual(expected, containsSyscall, assumption)
	}

	assertThat("should return true for syscall.Syscall instruction", "zsyscall_linux_amd64.go:310	0x47d56b		e8a0070000		CALL syscall.Syscall(SB)", true)
	assertThat("should return true for syscall.Syscall6 instruction", "sys_linux.go:149	0x4950b7		e8d48cfeff		CALL syscall.Syscall6(SB)		", true)
	assertThat("should return true for SYSCALL instruction", "sys_linux_amd64.s:535	0x4534f1		0f05			SYSCALL", true)
	assertThat("should return true for golang.org/x/sys/unix.Syscall instruction", "zsyscall_linux_amd64.go:442	0x48bd9a		e881030000		CALL golang.org/x/sys/unix.Syscall(SB)", true)
	assertThat("should return false for instructions containing syscall on their name", "proc.go:2853		0x430ab3		eb8b			JMP runtime.entersyscall_sysmon(SB)", false)
}

func TestTryPopSyscallID(t *testing.T) {

	assertThat := func(assumption, assemblyLine string, expectedID uint16, s *stack.Stack, expectedMatch bool) {
		should := should.New(t)
		actual, ok := tryPopSyscallID(assemblyLine, s)

		should.BeEqual(expectedMatch, ok, assumption)
		should.BeEqual(expectedID, actual, assumption)
	}

	stack := stack.New()
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd75		48c704247d000000	MOVQ $0x7d, 0(SP)				", stack)
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd7d		488b442440		MOVQ 0x40(SP), AX				", stack)
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd82		4889442408		MOVQ AX, 0x8(SP)					", stack)
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd91		48c744241800000000	MOVQ $0x0, 0x18(SP)				", stack)

	assertThat("should match main.main symbol", "zsyscall_linux_amd64.go:442	0x48bd9a		e881030000		CALL golang.org/x/sys/unix.Syscall(SB)", uint16(125), stack, true)
}

func TestStackSyscallIDIfNecessary(t *testing.T) {

	should := should.New(t)
	stack := stack.New()
	stackSyscallIDIfNecessary("zsyscall_linux_amd64.go:442	0x48bd75		48c704247d000000	MOVQ $0x7d, 0(SP)", stack)
	stackSyscallIDIfNecessary("sys_linux.go:230	0x49554e		48c70424fa000000		MOVQ $0xfa, 0(SP)", stack)
	stackSyscallIDIfNecessary("sys_linux_amd64.s:616	0x453aa5		48c7c702100000		MOVQ $0x1002, DI", stack)
	stackSyscallIDIfNecessary("sys_linux_amd64.s:617	0x453aac		48c7c09e000000		MOVQ $0x9e, AX", stack)

	should.BeEqual(3, stack.Len(), "should only stack potential ids")
	should.BeEqual(uint16(158), stack.Pop(), "should match ids in the correct order")
	should.BeEqual(uint16(250), stack.Pop(), "should match ids in the correct order")
	should.BeEqual(uint16(125), stack.Pop(), "should match ids in the correct order")
}
